# 制約からいって、1次元DPか……?
# 最大値最小値の保持はsegtreeが便利。だけど「何通り」を求めるのは難しそうだな。
# O(N+M)かO(K)か……
# DP? 新たに1列付け加える場合？ うまくいかない。

# 実験してみて分かったこと：
# min の max <= max の min (<の場合もある。例1の「1122」がそう。)

# min の max と max の min を1つ固定する。
# 例えば4 6 10 で、min の maxが5、max の minが8とする。
# 5 * * 8 5 * 
# 8 5 * * 8 5 
# * 8 5 * * 8 
# * * 8 5 * * 
# のように、斜め下に向かって5と8を入れる。すると各行の最小値は5、各列の最大値は8となる。
# 数字を入れ替えれば、各行の最小値は「5以下の任意の数」各列の最大値は「8以上の任意の数」にできる。

# 同様にすると、min の max <= max の minを満たすすべての組み合わせが作れる。
# が、このままだと固定が2つなのでO(K^2)かかるので不適切。
# min の maxだけ固定すれば良い。

# 1行m列の場合、m個のマスにKまでの数を自由に書くと各列の最大値はK^m通り。1行の最小値はそれに従属して一意に定まるので1通り。
# 結局K^m通りである。

# 累乗modを簡単に書けるPythonの面目躍如。（2回目）

n, m, k = list(map(int, input().split()))
mod = 998244353

if n == 1 and m == 1:
    print(k)
    exit()
elif n == 1 or m == 1:
    big = max(n, m)
    print(pow(k, big, mod))
    exit()

ans = 0
for i in range(1, k+1):
    ans += (pow(i, n, mod) - pow(i-1, n, mod)) * pow((k+1-i), m, mod)
print(ans % mod)
