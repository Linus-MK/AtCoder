公式のanalysisをdeepl翻訳して少し手直し。
やっぱ方針は合ってて計算量はO(D×N^2)。TLE……うーん……

ここで、「完全に使えるスライス」とは、必要なスライスを作るために、2～D等分に切ったり、そのまま使ったりして、使い切ることができるスライスのことを指します。つまり、「完全に使えるスライス」とは、余りが発生しないスライスのことです。

ここで重要な観察事項があります：私たちが生産するすべてのスライスについて、私たちが使用する各「完全に使えるスライス」から1つのスライスカットを除いて、1つのカットを使用する必要があります。つまり、D個の均等なスライスを作るためには、D-K回のカットが必要になります。ここで、Kは完全に使用されたスライスの数です。

D-1回のカット(K=1)で任意の元のスライスをカットすることで、常にD個の等しいスライスを生成することが可能です。
最良のケースは、我々が0回のカットを行うので、すでにD個の等しい元のスライスを持っている場合です(K=D)。
また、K=0を考慮する必要がないことにも注意してください。なぜなら、K=1は1つの元のスライスを等しく切断することで常に可能であり、我々は可能な限り最大のKを求めているからです。

上記の観察により、生成されたスライスの最終的なサイズ（以下、ターゲットサイズ）は、元のサイズ（完全に使用するスライスの1つから）を1とDの間の整数で割ったものになります。他のサイズの場合は、「完全に使えるスライス」は0個となります。

そのようなターゲット・スライス・サイズごとに、以下のことを行う必要があります。

最初に、実際に使用できるかどうかを確認します。すべての元のスライスを切断して生成できるこのサイズのスライスの合計数がDよりも少ない場合、明らかに、このサイズは我々にとって有用ではありません。サイズAiのスライスは、目標サイズsのフロア(Ai/s)までのスライスを生成するために使用することができる。
次に、すべての「完全に使えるスライス」を見つける必要があります：それらのサイズは、目標のスライスサイズで均等に分割され、残りはありません。
ここで、完全に使用可能な元のスライスの数を最大化する必要があるので、貪欲なアプローチを使用して、可能な限り多くの完全に使用可能な元のスライスが得られるまで（つまり、次のスライスを取ると、D個以上のターゲットスライスができてしまう状態まで）、サイズの昇順に1つずつスライスを取ることができます。もし、完全に使用可能な元のスライスを使い切ってしまったら、他の完全に使用可能でない元のスライスをどのような順番でも使用することができる。
先の観察のように、各完全に利用可能なオリジナル・スライスは、１つの「自由な」ターゲット・スライスを与えてくれます；他のすべてのターゲット・スライスは、生成されるためにそれぞれカットが必要です。つまり、現在のターゲットスライスサイズのためのカットの合計数は、Dから、我々が使用する完全に使用可能なオリジナルスライスの数であるKを引いたものになります。
上の部分は、最初にAisを一度（減らない順に）ソートすればO(N)時間で行うことができます。したがってアルゴリズム全体の時間の複雑さはO(D×N^2)です。

www.DeepL.com/Translator（無料版）で翻訳しました。