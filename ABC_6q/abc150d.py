# サンプル1を見ると、初項の15は公倍数30の半分やなー、公差は最小公倍数30やなー、と思う。

# Aの相異なる半公倍数がK, Lだったとすると,
# 半公倍数の定義より、L-KはAの全ての要素の倍数である。したがってAの公倍数である。
# また半公倍数Kに、Aの最小公倍数の整数倍を加えたものも、半公倍数になる。
# したがって、もし最小値Kを求められたら、Aの最小公倍数をLCM(A)とすると、半公倍数の集合はK + i*LCM(A)の等差数列になる。

# では最小値はどうすればよいか?
# 例えば8と16だとダメ。8の半公倍数は8k+4, 16の半公倍数は16k+8で、これは絶対一致しない。
# 倍数だとダメかというとそうとも限らない。8と24だと12が条件を満たす。

# やや天下りだけど。LCM(A) / 2が全要素の半公倍数になってればOK、そうでなければ半公倍数は存在しない。
# なぜなら、Aの半公倍数の2倍はAの公倍数でなければならない。
# 言い換えれば、半公倍数はAの公倍数を2で割ったものしか可能性はない、
# LCM(A) * 偶数 / 2だとLCM(A)の整数倍なので、半公倍数になる可能性はない。
# したがって残りは
# LCM(A) * 奇数 / 2 だけ。これがダメなら半公倍数は存在しない。

import math
n, m = list(map(int, input().split()))
nums = list(map(int, input().split()))

lcm = 1
for num in nums:
    lcm = lcm * num // math.gcd(num, lcm)
    if lcm > 10**9 * 2 + 10:
        print(0)
        exit()

for num in nums:
    if (lcm // num) % 2 == 0:
        # lcmの半分もnumの倍数である
        print(0)
        exit()

print((m + lcm // 2)// lcm)
