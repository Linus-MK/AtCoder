# arc062c.py 最初の2回の提出がWAになった理由は?

[1回目の提出](https://atcoder.jp/contests/arc062/submissions/5547838)  
005,009,012,013でWA ほかはAC

[2回目の提出](https://atcoder.jp/contests/arc062/submissions/5548116)  
005,012でWA ほかはAC

## 1回目の提出

ceil関数が浮動小数点演算でずれたか？  
……いや。この場合ならズレ始めた時点で倍率が1だけズレる。  
しかし、テストケース005を見ると、1だけズレてはいない。もっと多くズレている。なぜだろう。

テストケース005の計算途中では下記の計算をしている。

```python
>>> bairitsu = max(100484199978750000/1, 703389399851250000/6)
>>> bairitsu
1.17231566641875e+17
```

まずbairitsuは整数どうしを除算した結果なので、float型になる。  
そしてその精度には限りがあるので、ceilの引数になったときに不正確な値になる。  
（分数の正確な値は始めから表現できないのでそういう意味では始めから「不正確」だが、
その誤差が整数部分で発生するとその後の計算結果が期待と異なるものになる！）

```python
>>> a,b = 703389399851250000/6, 703389399851250000//6
>>> math.ceil(a), math.ceil(b)
(117231566641875008, 117231566641875000)
(※割り算の結果は117231566641875000に等しい)
```

テストケース009の差分は下記：

```python
>>> x,y = 409415303454045600, 65
>>> a,b = x/y, x//y
>>> b * y 
409415303454045590
>>> b * y  == x
False
>>> x - b * y
10
>>> a
6298696976216086.0
>>> math.ceil(a)
6298696976216086
>>> a == math.ceil(a)
True
```

除算の結果は 6298696976216086 + 10/65 だが、6298696976216086になってしまっている。精度不足のせい。  
あと2つのテストケースは未確認だけど同様の理由だろうなぁ。

結局理由としては**大きい数でfloat演算をしたときに、精度が足りずに整数部分が期待と異なる値になったから**となる。


## 2回目の提出

1回目の提出のエラーを特定しきれずに、「math.ceilを使わなければOKだろう」と思って書き直している。  
そのため、浮動小数点の除算 → int型にキャスト → batiritsuを掛け直して元の数より小さければ+1 としている。

テストケース005

正解：
[100484199978750000, 703389399851250000]
[117231566641875000, 703389399851250000]

2回目の提出：
[100484199978750000, 703389399851250000]
[117231566641875008, 703389399851250048]

```python
>>> x,y = 703389399851250000, 6
>>> a,b = x/y, x//y
>>> a
1.17231566641875e+17
>>> int(a)
117231566641875008
>>> b
117231566641875000
```

整数の部分も精度が失われてしまったから、int() でキャストしても真値より8も大きくなってしまった。

正解：
[51469399396119510, 34312932930746340]
[51469399396119510, 77204099094179265]

2回目の提出：
[51469399396119510, 34312932930746340]
[51469399396119512, 77204099094179268]

このときの入力は2:3と3:2の繰り返し。


```python
>>> x,y = 51469399396119510, 2
>>> a,b = x/y, x//y
>>> a
2.5734699698059756e+16
>>> int(a)
25734699698059756
>>> b
25734699698059755
```

1の位で精度が失われてしまったから、int() でキャストしても真値より1大きくなってしまった。

**除算でfloatを経由したのが真の問題**だったんだね。
